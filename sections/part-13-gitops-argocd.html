<section>
  <h1 style="color:#f5c84c;">GitOps with Argo CD (Production-grade Kubernetes Workflows)</h1>

  <p>
    GitOps is the evolution of DevOps.
    Instead of deploying from pipelines directly into clusters,
    <b>Git becomes the single source of truth</b> for everything that runs in Kubernetes.
  </p>

  <hr />

  <h2>1Ô∏è‚É£ What is GitOps?</h2>

  <p>
    GitOps is an operational model where:
  </p>

  <ul>
    <li>Git stores the desired state</li>
    <li>Kubernetes stores the live state</li>
    <li>A controller continuously reconciles the two</li>
  </ul>

  <pre>
Git Repository (Desired State)
        ‚Üì
GitOps Controller (Argo CD)
        ‚Üì
Kubernetes Cluster (Live State)
  </pre>

  <p>
    If someone manually changes the cluster,
    GitOps detects drift and corrects it automatically.
  </p>

  <hr />

  <h2>2Ô∏è‚É£ Why GitOps Matters in AKS</h2>

  <ul>
    <li>Auditable deployments</li>
    <li>Easy rollbacks</li>
    <li>Disaster recovery via Git</li>
    <li>Multi-cluster consistency</li>
  </ul>

  <p>
    In regulated industries, GitOps is not optional ‚Äî it is mandatory.
  </p>

  <hr />

  <h2>3Ô∏è‚É£ Argo CD Overview</h2>

  <p>
    Argo CD is a Kubernetes-native GitOps controller.
  </p>

  <ul>
    <li>Runs inside the cluster</li>
    <li>Continuously monitors Git</li>
    <li>Syncs manifests automatically</li>
    <li>Provides UI, CLI, and API</li>
  </ul>

  <pre>
Argo CD Components
 ‚îú‚îÄ‚îÄ API Server
 ‚îú‚îÄ‚îÄ Repository Server
 ‚îú‚îÄ‚îÄ Application Controller
 ‚îî‚îÄ‚îÄ Web UI
  </pre>

  <hr />

  <h2>4Ô∏è‚É£ Installing Argo CD on AKS</h2>

  <pre>
kubectl create namespace argocd

kubectl apply -n argocd \
  -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
  </pre>

  <p>
    Argo CD runs as Pods inside the cluster.
  </p>

  <hr />

  <h2>5Ô∏è‚É£ Argo CD Application (Core Concept)</h2>

  <p>
    An Argo CD Application defines:
  </p>

  <ul>
    <li>Where the Git repo is</li>
    <li>Which path contains manifests</li>
    <li>Which cluster & namespace to deploy to</li>
  </ul>

  <pre>
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
spec:
  source:
    repoURL: https://github.com/org/repo.git
    path: manifests
    targetRevision: main
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
  </pre>

  <hr />

  <h2>6Ô∏è‚É£ Automated Sync & Drift Detection</h2>

  <p>
    Argo CD continuously compares:
  </p>

  <ul>
    <li>Desired state (Git)</li>
    <li>Live state (Cluster)</li>
  </ul>

  <pre>
If Git ‚â† Cluster
 ‚Üí Argo CD reconciles
  </pre>

  <p>
    This eliminates configuration drift permanently.
  </p>

  <hr />

  <h2>7Ô∏è‚É£ GitOps vs CI/CD (Key Difference)</h2>

  <pre>
CI/CD:
Pipeline ‚Üí kubectl apply ‚Üí Cluster

GitOps:
Pipeline ‚Üí Git
Argo CD ‚Üí Cluster
  </pre>

  <p>
    CI builds artifacts.
    GitOps deploys artifacts.
  </p>

  <hr />

  <h2>8Ô∏è‚É£ Environment Promotion (Dev ‚Üí Test ‚Üí Prod)</h2>

  <p>
    Promotion happens via Git commits, not manual actions.
  </p>

  <pre>
dev branch  ‚Üí dev cluster
test branch ‚Üí test cluster
main branch ‚Üí prod cluster
  </pre>

  <p>
    Rollback = Git revert.
  </p>

  <hr />

  <h2>9Ô∏è‚É£ GitOps with Helm</h2>

  <p>
    Argo CD natively supports Helm charts.
  </p>

  <pre>
spec:
  source:
    repoURL: https://github.com/org/charts.git
    chart: myapp
    targetRevision: 1.2.3
    helm:
      values: |
        replicaCount: 3
  </pre>

  <p>
    This combines Helm templating with GitOps governance.
  </p>

  <hr />

  <h2>üîü Real Production Project Example</h2>

  <p>
    A SaaS company uses:
  </p>

  <ul>
    <li>GitHub for source</li>
    <li>GitHub Actions for CI</li>
    <li>Argo CD for CD</li>
    <li>AKS for runtime</li>
  </ul>

  <p>
    Result:
  </p>

  <ul>
    <li>Zero manual deployments</li>
    <li>Instant rollbacks</li>
    <li>Full audit trail</li>
  </ul>

  <hr />

  <h2>1Ô∏è‚É£1Ô∏è‚É£ Security Best Practices</h2>

  <ul>
    <li>Read-only Git access for Argo CD</li>
    <li>RBAC on Applications</li>
    <li>Private repositories</li>
    <li>Signed commits (optional)</li>
  </ul>

  <hr />

  <h2>1Ô∏è‚É£2Ô∏è‚É£ Common GitOps Mistakes</h2>

  <ul>
    <li>Allowing kubectl apply in prod</li>
    <li>Mixing imperative and declarative ops</li>
    <li>Not enforcing branch protection</li>
  </ul>

  <hr />

  <h2>üîç Interview Self-Check</h2>

  <p><b>Q:</b> What problem does GitOps solve?</p>
  <p><b>A:</b> Configuration drift and unsafe deployments.</p>

  <p><b>Q:</b> Who deploys in GitOps?</p>
  <p><b>A:</b> The cluster (via Argo CD), not humans.</p>

  <hr />

  <h2>‚û°Ô∏è What Comes Next?</h2>

  <p>
    GitOps enables safety.
    Now we study real-world failures and lessons learned.
  </p>

  <p style="color:#4da3ff;">
    üëâ Proceed to <b>Real AKS Incident Case Studies (Postmortems)</b>
  </p>
</section>
